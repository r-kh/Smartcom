# Smartcom.city

---
## Задача 2

### Прототип модуля для скачивания файлов

---

#### Инструменты, использованные при решении задачи

- Python, FastAPI, PostgreSQL, Redis, Celery
---
### Что реализовано
1) #### FastAPI-сервис с эндпоинтом /files/scan
    - Запускает задачу мониторинга активных SFTP-серверов
   
      Запуск задачи происходит через Celery (немедленная отдача ответа и параллельная обработка)


2) #### Работа с базой данных PostgreSQL:
    - Хранится список SFTP-серверов с их параметрами и статусом активности.
    - В таблице files фиксируются все обнаруженные файлы с их метаданными (имя, размер, статус, хэш и т.п.).
    - Даты создания и обновления записей фиксируются автоматически.


3) #### Мониторинг активных SFTP-серверов (задача scan_active_servers):
    - Получение из базы списка серверов с флагом is_active=True.
    - Для каждого активного сервера запускается отдельная Celery-задача discover_files_task.


4) #### Обнаружение новых файлов на SFTP-серверах (задача discover_files_task):
   - Подключение к SFTP-серверу.
   - Получение списка файлов из корневой директории.
   - Сравнение с записями в базе PostgreSQL.
   - Добавление новых файлов в базу с начальным статусом DISCOVERED.
   - Запуск задачи download_file_task для загрузки каждого нового файла.


5) #### Скачивание файлов с SFTP серверов (задача download_file_task):
    - скачивает файл с SFTP на локальный диск (tmp папка).
    - Обновляет статус файла в базе данных (DOWNLOADED при успехе, ERROR — при ошибке).

---
### Запуск

---

#### Основное приложение (FastAPI) запускается командой:
```bash
python main.py
```
(внутри запускается uvicorn, порт 9000)

---
#### Celery worker запускается командой:
```bash
celery -A tasks worker --loglevel=info --concurrency=2
```
---

### Пример запроса

#### POST /files/scan
```bash
curl -X POST http://localhost:9000/files/scan
```

---
## Задача 1

---
### Возможная архитектура подобного сервиса :
#### Вариант 1
- FastAPI - основной интерфейс приложения (управление серверами, мониторинг файлов, инициирование задач),
- PostgreSQL - хранение информации о серверах, файлах, статусах и логах,
- Celery+RabbitMQ - выполнение параллельных фоновых задач (скачивание, загрузка в MinIO, уведомления)
- MinIO - объектное хранилище для скачанных файлов 

#### Вариант 2
- То же самое, но, Temporal вместо Celery - более надёжное решение
---
#### Temporal
- Если нужна максимальная надёжность, особенно при риске денежных потерь.
- Если вы закладываете платформу на годы, и ошибка = деньги или репутация (Temporal окупится).
- Кто им пользуется для надёжных задач: Stripe(финансы), Netflix,
- кто уже из Enterprise перешёл с Celery на Temporal - WashingtonPost
---
### Схема БД

#### Таблицы: sftp_servers, files, file_events

---
**sftp_servers**
- базовая информация про серверы SFTP, на которых лежат файлы.

(вариант таблицы)

| id | server_uuid                             | name        | host           | port | username           | password_encrypted            | is_active | created_at           | updated_at           |
|----|-----------------------------------------|-------------|----------------|------|--------------------|--------------------------------|-----------|----------------------|----------------------|
| 1  | 1a2b3c4d-5e6f-7g8h-9i0j-k1l2m3n4o5p     | mts-sftp-1  | sftp.mts.ru    | 22   | user@smartcom.city | ***(AES-256, бинарные данные) | true      | 2025-08-06 12:00:00  | 2025-08-06 12:00:00  |
| 2  | 9z8y7x6w-5v4u-3t2s-1r0q-p9o8n7m6l5k     | local-sftp  | 192.168.1.100  | 2222 | admin              | ***(AES-256, бинарные данные) | false     | 2025-07-01 09:30:00  | 2025-08-01 14:15:00  |

---
**files**
- текущее состояние файлов

тут фиксируются все файлы, с которыми работает система, включая источник, статус, ошибки и путь в хранилище

(вариант таблицы)

| id | server_uuid                             | remote_path               | filename           | size_bytes | status     | file_hash                                                           | hash_algo | error_message                 | minio_object_key          | created_at               | updated_at               |
|----|-----------------------------------------|---------------------------|--------------------|------------|------------|---------------------------------------------------------------------|-----------|--------------------------------|---------------------------|--------------------------|--------------------------|
| 1  | 1a2b3c4d-5e6f-7g8h-9i0j-k1l2m3n4o5p     | /export/data/file1.csv    | file1.csv          | 204857600  | completed  | `5f70bf18a08660b7d6c2a3b3a4d5c12e8c0d6f2bcecc0bdf3f0ad1f8a1f6e4d1` | sha256    |                                | files/2025/08/file1.csv   | 2025-08-07 10:03:25.123  | 2025-08-07 10:06:01.332  |
| 2  | 9z8y7x6w-5v4u-3t2s-1r0q-p9o8n7m6l5k     | /daily/logs/log_20250807.gz | log_20250807.gz  | 10485760   | error      | `d41d8cd98f00b204e9800998ecf8427e`                                | md5       | Couldn't connect to server    |                           | 2025-08-07 10:10:14.552  | 2025-08-07 10:11:07.089  |

---
**file_events**
- журнал событий по каждому файлу

это бизнесовая история обработки файла (т.к. по условию - потеря файла приведет к убыткам компании)

(вариант таблицы)

| id | file_id | timestamp           | event_type         | details |
|----|---------|---------------------|--------------------|---------|
| 1  | 101     | 2025-08-07 14:01:03 | discovered         | `{ "path": "/export/data/file101.csv", "source": "mts-sftp-1" }` |
| 2  | 101     | 2025-08-07 14:01:05 | download_started   | `{ "server": "mts-sftp-1" }` |
| 3  | 101     | 2025-08-07 14:03:22 | downloaded         | `{ "size_mb": 2100, "duration_sec": 137, "temp_path": "/tmp/f101.tmp" }` |
| 4  | 101     | 2025-08-07 14:03:25 | minio_upload_start | `{ "target_bucket": "files", "target_key": "files/2025/08/file1.csv" }` |
| 5  | 101     | 2025-08-07 14:03:30 | minio_uploaded     | `{ "bucket": "files", "key": "files/2025/08/file1.csv", "etag": "abc123" }` |
| 6  | 101     | 2025-08-07 14:03:32 | amqp_notify_sent   | `{ "queue": "file_imports", "message_id": "amqp-4452" }` |

---
### На какие модули может быть разбито приложение :

| №  | Модуль          | Описание                                                                                                 |
|-----|-----------------|----------------------------------------------------------------------------------------------------------|
| 1   | **core/config** | Модуль с настройками и инициализацией общих компонентов (БД, SFTP, MinIO, RabbitMQ, Celery), используемых в остальных модулях. |
| 2   | **database**        | Модуль отвечает за локальное хранение данных для приложения (информация о серверах, файлах, их статусах, история обработки и т.п.). |
| 3   | **sftp_scanner**    | Модуль для отслеживания появления новых файлов на SFTP-серверах.                                         |
| 4   | **downloader**      | Модуль скачивания файлов с SFTP (контроль целостности файлов и временное локальное хранение).             |
| 5   | **uploader**        | Модуль загрузки скачанных файлов в MinIO (хранилище).                                                   |
| 6   | **notifier**        | Модуль уведомлений (отправляет события о новых файлах в AMQP (через RabbitMQ)).                         |
| 7   | **tasks**           | Модуль описания задач Celery и пайплайны обработки (координирует скачивание, загрузку, уведомления, обновление статуса в БД). Управляет ретраями, параллельной обработкой и очередями. |
| 8   | **web_interface**   | Модуль реализует веб-приложение с UI и REST API для управления серверами и мониторингом файлов.           |

---
### Алгоритм работы части, отвечающей за скачивание файлов

| Шаг | Описание                                                                                               |
|------|------------------------------------------------------------------------------------------------------|
| 1. Обнаружение новых файлов             | - Периодическая Celery-задача опрашивает SFTP-серверы, получает список файлов. <br> - Файлы сравниваются с БД (по метаданным и хэшу). <br> - Для каждого нового файла вызывается шаг 2. |
| 2. Инициализация задачи для скачивания | - Для каждого нового файла создаётся Celery-задача скачивания (асинхронно, параллельно, с ретраями). <br> - Задача вызывает шаг 3 — скачивание файла. |
| 3. Скачивание                          | - Файл скачивается во временный локальный каталог частями, с проверкой размера и хэша (если возможно). <br> - По завершении вызывается шаг 4 — загрузка в MinIO. |
| 4. Загрузка в MinIO                    | - После успешной загрузки в temp — файл отправляется в MinIO. <br> - Проверяется контрольная сумма. <br> - Затем вызывается шаг 5 — обновление БД. |
| 5. Фиксация результата                 | - Обновляется статус файла в БД, сохраняются хэш, размер, время. <br> - Вызывается шаг *. Отправка уведомления в AMQP о готовности файла. |
| *. Отправка уведомления в AMQP         | - Отправляется сообщение о готовности файла внешнему сервису через AMQP.                          |

---
### Какие подводные камни необходимо учесть при реализации алгоритмов

| Шаг                                   | Подводные камни и решения                                                                                                                                                                                                                                                                                                                                  |
|--------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 1. Обнаружение новых файлов           | - Серверы могут быть временно недоступны — логировать, но не сбрасывать задачу.<br> - Файлы могут быть в процессе записи — если скачивать слишком рано, получим обрезанный файл (решение: проверять, что файл не меняется по размеру N секунд).<br> - Имя файла не всегда уникально — ориентироваться на размер, дату и (если возможно) контрольную сумму. |
| 2. Инициализация Celery-задачи        | - Дублирование задач: повторный запуск не должен порождать скачивание одного и того же файла дважды.<br> - Сбой брокера (RabbitMQ): задачи могут застрять, нужно отслеживать «висящие» задачи.                                                                                                                                                             |
| 3. Скачивание                        | - Прерывание сети во время скачивания (решение: использовать библиотеку с поддержкой resume).<br> - Недостаточно места на диске — перед скачиванием проверять свободное место с запасом.<br> - Файл скачан не полностью или повреждён — верифицировать по размеру и по хэшу (если известно).                                                               |
| 4. Загрузка в MinIO                  | - Проблемы с сетью или недоступность MinIO — ретраи обязательны.<br> - Неполная загрузка — сравнивать хэш и размер после загрузки.<br> - Проверять, что объект ещё не существует, использовать уникальные ключи.                                                                                                                                           |
| 5. Фиксация результата               | - Проблемы с БД: потеря соединения — повторять обновление, нельзя терять информацию о статусе файла.                                                                                                                                                                                                                                                       |

---
### Общие подводные камни

| Категория                | Подводные камни и рекомендации                                                                                      |
|-------------------------|--------------------------------------------------------------------------------------------------------------------|
| Идемпотентность          | - Все шаги (особенно скачивание, загрузка, уведомление) должны быть идемпотентны, чтобы повторный запуск не приводил к дублированию или порче данных. |
| Обработка ошибок и ретраи | - Celery-задачи обязательно должны иметь retry policy и логировать причины неудач.                                 |
| Очистка временных файлов | - При обрыве процесса не должно оставаться мусора на диске.                                                       |
| Тестирование нагрузки    | Протестировать на больших объёмах, чтобы выявить узкие места:<br>   - имитировать 100-500 параллельных загрузок<br>   - имитировать 10-100 ГБ файлов |

---
###  Какие внештатные ситуации могут произойти

#### Аварийная ситуация

Возможные проблемы после внештатного перезапуска сервиса:

| Проблема                  | Описание и последствия                                                                                          |
|--------------------------|----------------------------------------------------------------------------------------------------------------|
| Потерянные задачи в Celery | - Задача была взята в работу, но не завершена.<br> - Возможен статус файла "в процессе", хотя фактически ничего не происходит.<br><br>Результат: файл не обрабатывается и не будет обработан повторно без механизма обнаружения «висячих» задач. |
| Неполностью обработанные файлы | - Скачивание началось, но оборвалось — остался мусор на диске.<br> - Файл загружен в MinIO, но временный файл не удалён, статус в БД не обновлён, AMQP-уведомление не отправлено.<br><br>Результат: файл есть в MinIO, но система не знает об этом. |

Нужны корректные настройки в Celery и retry-политики на эти случаи (реанимация задач)

+Очистка мусора: сканирование временного каталога, удаление старых файлов.